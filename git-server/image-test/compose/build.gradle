
plugins {
   id 'com.palantir.docker-compose' version '0.34.0'
}


apply from: "$rootProject.projectDir/git-server/project.properties"
apply from: "$rootProject.projectDir/git-server/image/project.properties"
apply from: "$rootProject.projectDir/git-server/image-test/image/project.properties"

// from properties files above:
   def registry = registry_name
   // gitServer_imageName
   // gitServer_imageVersion
   // gitClient_imageName
   // gitClient_imageVersion



dockerCompose {
   dockerComposeFile 'build/docker-compose.yml'
}



tasks.register( 'prepComposeFile' ) {

       delete 'build/'

       delete 'test-deploy/'
       mkdir 'test-deploy/git-server/'

       def projectDir = project( ':git-server:image-test:compose' ).getProjectDir( ).getAbsolutePath( )
       def gitServer_repoPath = projectDir + "/test-deploy/git-server/repo"
       def gitServer_dataPath = projectDir + "/test-deploy/git-server/data"

       def username = System.properties[ 'user.name' ]
       def uid = [ "id", "-u", username ].execute( ).text.trim( )

       copy {
         from 'src/main/docker-compose'
         include '*.yml'
         into 'build/'
         expand( [
                  registry: registry,
                  gitServer_imageName: gitServer_imageName,
                  gitServer_imageVersion: gitServer_imageVersion,
                  gitServer_uid: uid,
                  gitServer_repoPath: gitServer_repoPath,
                  gitServer_dataPath: gitServer_dataPath,
                  gitClient_imageName: gitClient_imageName,
                  gitClient_imageVersion: gitClient_imageVersion
                 ] ) 
       }
}


tasks.register( 'test' ) {

   dependsOn = [
                ':git-server:image:docker',
                ':git-server:image-test:image:docker',
                'prepComposeFile',
                ':git-server:image-test:compose:dockerComposeUp'
               ]

   project.getTasks( ).getByPath( ':git-server:image-test:compose:dockerComposeUp' ).mustRunAfter( ':git-server:image:docker' )
   project.getTasks( ).getByPath( ':git-server:image-test:compose:dockerComposeUp' ).mustRunAfter( ':git-server:image-test:image:docker' )
   project.getTasks( ).getByPath( ':git-server:image-test:compose:dockerComposeUp' ).mustRunAfter( 'prepComposeFile' )


   finalizedBy ':git-server:image-test:compose:dockerComposeDown'


   doLast {

      Map<String, String> result
      String[] cmdArray



      // ***************************
      // ***************************
      // WAIT FOR CONTAINERS 'RUNNING'

      // Wait for containers to run (e.g. reach 'running' state)

      Set<String> containerSet = new HashSet<String>( )
      containerSet.add( "git-server" )
      containerSet.add( "git-client-john" )
      containerSet.add( "git-client-jane" )
      result = waitForContainerStateRunning( containerSet )

      // throw error if containers fail to reach 'running' state (num retries or 'exited' state)
      if ( !result.get( 'success' ) ) {

         Throwable t;

         if ( result.get( 'reason' ).equalsIgnoreCase( 'Container exited' ) ) {
            t = new Throwable( "Container '" + result.get( 'container' ) + "' exited." )
         } else if ( result.get( 'reason' ).equalsIgnoreCase( 'Num retries' ) ) {
            t = new Throwable( "Number of retries exceeded with container '" + result.get( 'container' ) + "'." )
         } else {
            t = new Throwable( result.get( 'result' ) )
         }

         throw new GradleScriptException( "Error starting containers", t )
      }


      // ***************************
      // ***************************
      // CREATE REPOS


      // create repo A

      result = exec( "docker exec git-server /git-create-repo.sh testRepoA" )

      if ( result.get( "exitValue" ) != 0 ) {
         Throwable t = new Throwable( "Creating repository 'testRepoA' returned non-zero exit value of " + result.get( "exitValue" ) + " with error message " + result.get( "err" ) )
         throw new GradleScriptException( "Error creating repository", t )
      } else if ( !result.get( "out" ).equals( "Initialized empty Git repository in /srv/git/testRepoA/" ) ) {
         Throwable t = new Throwable( "Creating repository 'testRepoA' returned unexpected response of " + result.get( "out" ) )
         throw new GradleScriptException( "Error creating repository", t )
      }



      // create repo B

      result = exec( "docker exec git-server /git-create-repo.sh testRepoB" )

      if ( result.get( "exitValue" ) != 0 ) {
         Throwable t = new Throwable( "Creating repository 'testRepoB' returned non-zero exit value of " + result.get( "exitValue" ) + " with error message " + result.get( "err" ) )
         throw new GradleScriptException( "Error creating repository", t )
      } else if ( !result.get( "out" ).equals( "Initialized empty Git repository in /srv/git/testRepoB/" ) ) {
         Throwable t = new Throwable( "Creating repository 'testRepoB' returned unexpected response of " + result.get( "out" ) )
         throw new GradleScriptException( "Error creating repository", t )
      }




      // ***************************
      // ***************************
      // REPO A: JOHN clone, create file, push


      // clone

      result = exec( "docker exec --user git git-client-john git clone git://git-server/testRepoA" )

      if ( result.get( "exitValue" ) != 0 ) {

         String err = result.get ( 'err' )
         String msg = 'Could not perform initial clone of repository A for John.'

         if ( err == null ) {
            err = msg
         } else {
            err = err + ' ' + msg
         }

         Throwable t = new Throwable( "Error cloning repository with non-zero exit value of " + result.get( "exitValue" ) + " with error message " + result.get( "err" ) )
         throw new GradleScriptException( "Error cloning repository", t )
      }


      // create file

      cmdArray = [ "docker", "exec", "--user", "git", "git-client-john", "/bin/ash", "-c", "echo 'hi' > /repos/testRepoA/blah.txt" ]
      result = exec( cmdArray )

      if ( result.get( "exitValue" ) != 0 ) {

         String err = result.get ( 'err' )
         String msg = 'Could not create file "blah.txt" in repository A for John.'

         if ( err == null ) {
            err = msg
         } else {
            err = err + ' ' + msg
         }

         Throwable t = new Throwable( "Error creating file in repository with non-zero exit value of " + result.get( "exitValue" ) + " with error message " + result.get( "err" ) )
         throw new GradleScriptException( "Error creating file", t )
      }



      // add file created for staging and commit

      cmdArray = [ "docker", "exec", "--user", "git", "git-client-john", "/bin/ash", "-c", "cd testRepoA && git add . && git commit -m 'Initial commit'" ]
      result = exec( cmdArray )

      if ( result.get( "exitValue" ) != 0 ) {

         String err = result.get ( 'err' )
         String msg = 'Could not perform initial stage of file "blah.txt" and/or commit in repository A for John.'

         if ( err == null ) {
            err = msg
         } else {
            err = err + ' ' + msg
         }

         Throwable t = new Throwable( "Error staging file and/or committing file in repository with non-zero exit value of " + result.get( "exitValue" ) + " with error message " + result.get( "err" ) )
         throw new GradleScriptException( "Error staging and/or committing file repository", t )
      }


      // push

      cmdArray = [ "docker", "exec", "--user", "git", "git-client-john", "/bin/ash", "-c", "cd testRepoA && git push" ]
      result = exec( cmdArray )

      if ( result.get( "exitValue" ) != 0 ) {

         String err = result.get ( 'err' )
         String msg = 'Could not perform initial push of changes for remote repository A for John.'

         if ( err == null ) {
            err = msg
         } else {
            err = err + ' ' + msg
         }

         Throwable t = new Throwable( "Error pushing updates to remote repository with non-zero exit value of " + result.get( "exitValue" ) + " with error message " + result.get( "err" ) )
         throw new GradleScriptException( "Error pushing to remote repository", t )
      }



      // ***************************
      // ***************************
      // REPO A: JANE clone, create file, edit file, push


      // clone

      result = exec( "docker exec --user git git-client-jane git clone git://git-server/testRepoA" )

      if ( result.get( "exitValue" ) != 0 ) {

         String err = result.get ( 'err' )
         String msg = 'Could not perform initial clone of repository A for Jane.'

         if ( err == null ) {
            err = msg
         } else {
            err = err + ' ' + msg
         }

         Throwable t = new Throwable( "Error cloning repository with non-zero exit value of " + result.get( "exitValue" ) + " with error message " + result.get( "err" ) )
         throw new GradleScriptException( "Error cloning repository", t )
      }


      // create file

      cmdArray = [ "docker", "exec", "--user", "git", "git-client-jane", "/bin/ash", "-c", "echo 'howdy' > /repos/testRepoA/yada.txt" ]
      result = exec( cmdArray )

      if ( result.get( "exitValue" ) != 0 ) {

         String err = result.get ( 'err' )
         String msg = 'Could not create file "yada.txt" in repository A for Jane.'

         if ( err == null ) {
            err = msg
         } else {
            err = err + ' ' + msg
         }

         Throwable t = new Throwable( "Error creating file in repository with non-zero exit value of " + result.get( "exitValue" ) + " with error message " + result.get( "err" ) )
         throw new GradleScriptException( "Error creating file", t )
      }


      // edit file

      cmdArray = [ "docker", "exec", "--user", "git", "git-client-jane", "/bin/ash", "-c", "echo 'hey' >> /repos/testRepoA/blah.txt" ]
      result = exec( cmdArray )

      if ( result.get( "exitValue" ) != 0 ) {

         String err = result.get ( 'err' )
         String msg = 'Could not edit file "blah.txt" in repository A for Jane.'

         if ( err == null ) {
            err = msg
         } else {
            err = err + ' ' + msg
         }

         Throwable t = new Throwable( "Error creating file in repository with non-zero exit value of " + result.get( "exitValue" ) + " with error message " + result.get( "err" ) )
         throw new GradleScriptException( "Error creating file", t )
      }


      // add files created and edited for staging and commit

      cmdArray = [ "docker", "exec", "--user", "git", "git-client-jane", "/bin/ash", "-c", "cd testRepoA && git add . && git commit -m 'Initial commit'" ]
      result = exec( cmdArray )

      if ( result.get( "exitValue" ) != 0 ) {

         String err = result.get ( 'err' )
         String msg = 'Could not perform initial stage of files "blah.txt", "yada.txt", and/or commit in repository A for Jane.'

         if ( err == null ) {
            err = msg
         } else {
            err = err + ' ' + msg
         }

         Throwable t = new Throwable( "Error staging file and/or committing file in repository with non-zero exit value of " + result.get( "exitValue" ) + " with error message " + result.get( "err" ) )
         throw new GradleScriptException( "Error staging and/or committing file repository", t )
      }


      // push

      cmdArray = [ "docker", "exec", "--user", "git", "git-client-jane", "/bin/ash", "-c", "cd testRepoA && git push" ]
      result = exec( cmdArray )

      if ( result.get( "exitValue" ) != 0 ) {

         String err = result.get ( 'err' )
         String msg = 'Could not perform initial push of changes for remote repository A for Jane.'

         if ( err == null ) {
            err = msg
         } else {
            err = err + ' ' + msg
         }

         Throwable t = new Throwable( "Error pushing updates to remote repository with non-zero exit value of " + result.get( "exitValue" ) + " with error message " + result.get( "err" ) )
         throw new GradleScriptException( "Error pushing to remote repository", t )
      }



      // ***************************
      // ***************************
      // REPO A: JOHN pull, check files/contents


      // pull

      cmdArray = [ "docker", "exec", "--user", "git", "git-client-john", "/bin/ash", "-c", "cd testRepoA && git pull" ]
      result = exec( cmdArray )

      if ( result.get( "exitValue" ) != 0 ) {

         String err = result.get ( 'err' )
         String msg = 'Could not perform pull of repository A for John.'

         if ( err == null ) {
            err = msg
         } else {
            err = err + ' ' + msg
         }

         Throwable t = new Throwable( "Error pulling repository with non-zero exit value of " + result.get( "exitValue" ) + " with error message " + result.get( "err" ) )
         throw new GradleScriptException( "Error pulling repository", t )
      }


      // files present

      cmdArray = [ "docker", "exec", "--user", "git", "git-client-john", "/bin/ash", "-c", "cd testRepoA && ls -l blah.txt && ls -l yada.txt" ]
      result = exec( cmdArray )

      if ( result.get( "exitValue" ) != 0 ) {

         String err = result.get ( 'err' )
         String msg = 'Expected files not present in repository A for John.'

         if ( err == null ) {
            err = msg
         } else {
            err = err + ' ' + msg
         }

         Throwable t = new Throwable( "Error expected files not present in repository with ls of files resulsting in non-zero exit value of " + result.get( "exitValue" ) + " with error message " + result.get( "err" ) )
         throw new GradleScriptException( "Error expected files not present in repository", t )
      }


      // files have expected contents

      cmdArray = [ "docker", "exec", "--user", "git", "git-client-john", "/bin/ash", "-c", "echo 'hi' > /repos/testRepoA/blah-expected.txt" ]
      result = exec( cmdArray )

      cmdArray = [ "docker", "exec", "--user", "git", "git-client-john", "/bin/ash", "-c", "echo 'hey' >> /repos/testRepoA/blah-expected.txt" ]
      result = exec( cmdArray )


      cmdArray = [ "docker", "exec", "--user", "git", "git-client-john", "/bin/ash", "-c", "diff /repos/testRepoA/blah.txt /repos/testRepoA/blah-expected.txt" ]
      result = exec( cmdArray )

      if ( result.get( "exitValue" ) != 0 ) {

         String err = result.get ( 'err' )
         String msg = 'Files with unexpected contents for repository A for John.'

         if ( err == null ) {
            err = msg
         } else {
            err = err + ' ' + msg
         }

         Throwable t = new Throwable( "Error file contents not as expected for diff of 'blah.txt' and 'blah-expected.txt' resulsting in non-zero exit value of " + result.get( "exitValue" ) + " with error message " + result.get( "err" ) )
         throw new GradleScriptException( "Error file contents not expected", t )
      }


      cmdArray = [ "docker", "exec", "--user", "git", "git-client-john", "/bin/ash", "-c", "echo 'howdy' > /repos/testRepoA/yada-expected.txt" ]
      result = exec( cmdArray )

      cmdArray = [ "docker", "exec", "--user", "git", "git-client-john", "/bin/ash", "-c", "diff /repos/testRepoA/yada.txt /repos/testRepoA/yada-expected.txt" ]
      result = exec( cmdArray )

      if ( result.get( "exitValue" ) != 0 ) {

         String err = result.get ( 'err' )
         String msg = 'Files with unexpected contents for repository A for John.'

         if ( err == null ) {
            err = msg
         } else {
            err = err + ' ' + msg
         }

         Throwable t = new Throwable( "Error file contents not as expected for diff of 'yada.txt' and 'yada-expected.txt' resulsting in non-zero exit value of " + result.get( "exitValue" ) + " with error message " + result.get( "err" ) )
         throw new GradleScriptException( "Error file contents not expected", t )
      }



      // ***************************
      // ***************************
      // REPO B: JOHN clone, create file, push


      // clone

      result = exec( "docker exec --user git git-client-john git clone git://git-server/testRepoB" )

      if ( result.get( "exitValue" ) != 0 ) {

         String err = result.get ( 'err' )
         String msg = 'Could not perform initial clone of repository B for John.'

         if ( err == null ) {
            err = msg
         } else {
            err = err + ' ' + msg
         }

         Throwable t = new Throwable( "Error cloning repository with non-zero exit value of " + result.get( "exitValue" ) + " with error message " + result.get( "err" ) )
         throw new GradleScriptException( "Error cloning repository", t )
      }


      // create file

      cmdArray = [ "docker", "exec", "--user", "git", "git-client-john", "/bin/ash", "-c", "echo 'asdf' > /repos/testRepoB/blah.txt" ]
      result = exec( cmdArray )

      if ( result.get( "exitValue" ) != 0 ) {

         String err = result.get ( 'err' )
         String msg = 'Could not create file "blah.txt" in repository B for John.'

         if ( err == null ) {
            err = msg
         } else {
            err = err + ' ' + msg
         }

         Throwable t = new Throwable( "Error creating file in repository with non-zero exit value of " + result.get( "exitValue" ) + " with error message " + result.get( "err" ) )
         throw new GradleScriptException( "Error creating file", t )
      }



      // add file created for staging and commit

      cmdArray = [ "docker", "exec", "--user", "git", "git-client-john", "/bin/ash", "-c", "cd testRepoB && git add . && git commit -m 'Initial commit'" ]
      result = exec( cmdArray )

      if ( result.get( "exitValue" ) != 0 ) {

         String err = result.get ( 'err' )
         String msg = 'Could not perform initial stage of file "blah.txt" and/or commit in repository B for John.'

         if ( err == null ) {
            err = msg
         } else {
            err = err + ' ' + msg
         }

         Throwable t = new Throwable( "Error staging file and/or committing file in repository with non-zero exit value of " + result.get( "exitValue" ) + " with error message " + result.get( "err" ) )
         throw new GradleScriptException( "Error staging and/or committing file repository", t )
      }


      // push

      cmdArray = [ "docker", "exec", "--user", "git", "git-client-john", "/bin/ash", "-c", "cd testRepoB && git push" ]
      result = exec( cmdArray )

      if ( result.get( "exitValue" ) != 0 ) {

         String err = result.get ( 'err' )
         String msg = 'Could not perform initial push of changes for remote repository B for John.'

         if ( err == null ) {
            err = msg
         } else {
            err = err + ' ' + msg
         }

         Throwable t = new Throwable( "Error pushing updates to remote repository with non-zero exit value of " + result.get( "exitValue" ) + " with error message " + result.get( "err" ) )
         throw new GradleScriptException( "Error pushing to remote repository", t )
      }


      // backup

      cmdArray = [ "docker", "exec", "--user", "git", "git-server", "/bin/ash", "-c", "date +%F" ]
      result = exec( cmdArray )
      String dateBefore = result.get( "out" )

      cmdArray = [ "docker", "exec", "--user", "git", "git-server", "/bin/ash", "-c", "/cron/scripts/git-backup.sh" ]
      result = exec( cmdArray )

      if ( result.get( "exitValue" ) != 0 ) {

         String err = result.get ( 'err' )
         String msg = 'Could not perform initial backup of repositories.'

         if ( err == null ) {
            err = msg
         } else {
            err = err + ' ' + msg
         }

         Throwable t = new Throwable( "Error backing up repositories with '/cron/scripts/git-backup.sh' script with non-zero exit value of " + result.get( "exitValue" ) + " with error message " + result.get( "err" ) )
         throw new GradleScriptException( "Error backing up repositories", t )
      }

      cmdArray = [ "docker", "exec", "--user", "git", "git-server", "/bin/ash", "-c", "date +%F" ]
      result = exec( cmdArray )
      String dateAfter = result.get( "out" )


      // backup of all repositories file is present
      //    - output format:  <YYYY-MM-DD>-all-git-repos.tar.gz
      //    - will check for presence of file with date BEFORE and AFTER running the backup command, in the slight chance the command was executed around midnight and hence the date would be differ by a day

      String backupDir = projectDir.toString( ) + "/test-deploy/git-server/data"
      String backupFilePostfix = "-all-git-repos.tar.gz"
      String dateCurrent = dateBefore
      String backupFile = backupDir + "/" + dateCurrent + backupFilePostfix
      def projectDir = project(':git-server:image-test:compose').getProjectDir( ).getAbsolutePath( )

      cmdArray = [ "ls", backupFile ]
      result = exec( cmdArray )


      if ( result.get( "exitValue" ) != 0 ) {

         String err = "Backup file '" + backupFile + "'"

         if ( !dateBefore.equalsIgnoreCase( dateAfter ) ) {
            // try 'dateAfter' if that differs from 'dateBefore'

            dateCurrent = dateAfter

            backupFile = backupDir + "/" + dateCurrent + backupFilePostfix

            cmdArray = [ "ls", backupFile ]
            result = exec( cmdArray )

            if ( result.get( "exitValue" ) != 0 ) {
               err += " or '" + backupFile + "'"
            }

         }

            if ( result.get( "exitValue" ) != 0 ) {

            Throwable t = new Throwable( err + " not found." )
            throw new GradleScriptException( "Error finding backup file", t )
         }

      }



      // untar and unzip backup of all repositories file
      cmdArray = [ "tar", "xfv", backupFile, "-C", backupDir ]
      result = exec( cmdArray )

      if ( result.get( "exitValue" ) == 0 ) {

         // Example format:
         // <YYYY-MM-DD>-all-git-repos
         //    testRepoA-git-repo-<YYYY-MM-DD>.tar.gz
         //    testRepoB-git-repo-<YYYY-MM-DD>.tar.gz

         String extractDir = backupDir + "/" + dateCurrent + "-all-git-repos"
         String backupFileRepoA = extractDir + "/testRepoA-git-repo-" + dateCurrent + ".tar.gz"
         String backupFileRepoB = extractDir + "/testRepoB-git-repo-" + dateCurrent + ".tar.gz"

         cmdArray = [ "ls", backupFileRepoA ]
         result = exec( cmdArray )

         if ( result.get( "exitValue" ) == 0 ) {

            cmdArray = [ "ls", backupFileRepoB ]
            result = exec( cmdArray )

            if ( result.get( "exitValue" ) == 0 ) {


               // testRepoA:  untar and unzip backup file
               cmdArray = [ "tar", "xfv", backupFileRepoA, "-C", backupDir ]
               result = exec( cmdArray )

               if ( result.get( "exitValue" ) == 0 ) {

                  cmdArray = [ "ls", backupDir + "/testRepoA/HEAD" ]
                  result = exec( cmdArray )

                  if ( result.get( "exitValue" ) == 0 ) {


                     // testRepoB:  untar and unzip backup file
                     cmdArray = [ "tar", "xfv", backupFileRepoB, "-C", backupDir ]
                     result = exec( cmdArray )

                     if ( result.get( "exitValue" ) == 0 ) {

                        cmdArray = [ "ls", backupDir + "/testRepoB/HEAD" ]
                        result = exec( cmdArray )

                        if ( result.get( "exitValue" ) != 0 ) {
                           Throwable t = new Throwable( "Expected contents not present for testRepoB backfile file '" + backupFile + "'" )
                           throw new GradleScriptException( "Error for contents for backfile for testRepoB", t )
                        }


                     } else {
                        Throwable t = new Throwable( "Could not untar and unzip testRepoB backfile file '" + backupFile + "'" )
                        throw new GradleScriptException( "Error untarring and unzipping backfile for testRepoB", t )
                     }


                  } else {
                     Throwable t = new Throwable( "Expected contents not present for testRepoA backfile file '" + backupFile + "'" )
                     throw new GradleScriptException( "Error for contents for backfile for testRepoA", t )
                  }


               } else {
                  Throwable t = new Throwable( "Could not untar and unzip testRepoA backfile file '" + backupFile + "'" )
                  throw new GradleScriptException( "Error untarring and unzipping backfile for testRepoA", t )
               }


            } else {
               Throwable t = new Throwable( "Backfile file for repository 'testRepoB' at " + backupFileRepoB + "' not present" )
               throw new GradleScriptException( "Error untarring and unzipping backupfile of all repositories for 'testRepoB'", t )
            }

         } else {
            Throwable t = new Throwable( "Backfile file for repository 'testRepoA' at " + backupFileRepoA + "' not present" )
            throw new GradleScriptException( "Error untarring and unzipping backupfile of all repositories for 'testRepoA'", t )
         }

      } else {
         Throwable t = new Throwable( "Could not untar and unzip backfile file of all repositories '" + backupFile + "'" )
         throw new GradleScriptException( "Error untarring and unzipping backfile of all repositories", t )
      }


   }



}



configure( test ) {   
    group = 'git-server'
    description = 'Tests the git-server.  Builds test Docker image and git-server image and executes tests.'
}





Map<String, String> waitForContainerStateRunning( String container ) {
   Set<String> containerSet = new HashSet<String>( )
   containerSet.add( container )
   return( waitForContainerStateRunning( containerSet ) )
}

Map<String, String> waitForContainerStateRunning( String container, int retrySeconds, int retryNum ) {
   Set<String> containerSet = new HashSet<String>( )
   containerSet.add( container )
   return( waitForContainerStateRunning( containerSet, retrySeconds, retryNum ) )
}


Map<String, String> waitForContainerStateRunning( Set<String> containerSet ) {
   return( waitForContainerStateRunning( containerSet, 2, 10 ) )
}


/**
  * Waits for a set of containers to reach 'running' state.
  * <p>
  * Queries for containers' states when the function is called (no initial delay) and, if all containers are not running, then will retry 'retryNum' times waiting 'retrySeconds' between attempts.  If one container has not reached 'running' state, then subsequent retries will always retry all containers with the intent that, although a container reaches 'running' state, it can exit later.
  * <p>
  * The containers will be queried until (1) all containers are in a 'running' state, (2) the number of retries was hit, or (3) at least one container exited.
  * <p>
  * Even if all containers are detected as running and this function returns 'success', health checks specific to the container service should be performed to ensure the services are available.
  * <p>
  * Returns a Map with results with the following keys:
  * <ul>
  *   <li>success = boolean true if all containers in a 'running' state and false otherwise</li>
  *   <li>reason = the reason the operation failed which can be 'Container exited' or 'Num retries'; present only if 'success' is false</li>
  *   <li>container = the container that exited if reason is 'Container exited' or the first container that didn't start if reason is 'Num retries'; present only if 'success' is false</li>
  * </ul>
  *
  *
  */
Map<String, String> waitForContainerStateRunning( Set<String> containerSet, int retrySeconds, int retryNum ) {

   Map<String, String> result = new HashMap<String, String>( )
   result.put( "success", false )

   boolean done= false
   int count = 0

   // loop local variables
   boolean proceed // current container in 'running' state
   String currentContainer
   String containerState
   Map<String, String> queryResult

   while ( !done ) {

      proceed = true

      Iterator it = containerSet.iterator( )

      while ( proceed && it.hasNext( ) ) {

         proceed = false

         currentContainer = it.next( )

         queryResult = getContainerState( currentContainer )

         if ( queryResult.get( "exitValue" ) == 0 ) {

            containerState = queryResult.get( "out" )

            if ( containerState.equalsIgnoreCase( "running" ) ) {
               proceed = true
            } else if ( containerState.equalsIgnoreCase( "exited" ) ) {
               // implicit proceed = false
               done = true
               result.put( "reason", "Container exited" )
               result.put( "container", currentContainer )
            }  // implicit else with proceed = false
               // Container is being created or starting.  There are other states which don't apply in this context.

         }

      }

      if ( !done && !it.hasNext( ) && proceed ) {
         done = true
         result.put( "success", true )
      } else if ( done ) {
         // catches failure cases and data provided above, preventing the next 'else' with 'Num retries' from over-writing
      } else {

         count++

         if ( count == retryNum + 1 ) {
            done = true
            result.put( "reason", "Num retries" )
            result.put( "container", currentContainer )
         } else {
            Thread.sleep( retrySeconds * 1000 )
         }

      }

   }


   return( result )
}


Map<String, String> getContainerState( String container ) {

      Map<String, String> data = exec( "docker inspect --format {{.State.Status}} " + container )

      return( data )
}


Map<String, String> exec( String task ) {

   Map<String, String> result = new HashMap<String, String>( )

   StringBuffer sout = new StringBuffer( )
   StringBuffer serr = new StringBuffer( )

   Process proc = task.execute( )
   proc.consumeProcessOutput( sout, serr )
   proc.waitFor( )

   int exitValue = proc.exitValue( )
   result.put( 'exitValue', exitValue )

   result.put( 'out', sout.toString( ).trim( ) )

   if ( exitValue < 0 || exitValue > 0 ) {
      result.put( 'err', serr.toString( ).trim( ) )
   }


   return( result )

}


Map<String, String> exec( String[] task ) {

   Map<String, String> result = new HashMap<String, String>( )

   StringBuffer sout = new StringBuffer( )
   StringBuffer serr = new StringBuffer( )

   Process proc = task.execute( )
   proc.consumeProcessOutput( sout, serr )
   proc.waitFor( )

   int exitValue = proc.exitValue( )
   result.put( 'exitValue', exitValue )

   result.put( 'out', sout.toString( ).trim( ) )

   if ( exitValue < 0 || exitValue > 0 ) {
      result.put( 'err', serr.toString( ).trim( ) )
   }


   return( result )

}
